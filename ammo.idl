
// Compatibility

interface btCompat {
  void setInternalTickCallback(btDynamicsWorld world, VoidPtr cb, optional VoidPtr worldUserInfo, optional boolean isPreTick);
};

// Debug drawer

interface btIDebugDraw {
  void drawLine([Const, Ref] btVector3 from, [Const, Ref] btVector3 to, [Const, Ref] btVector3 color);
  void drawContactPoint([Const, Ref] btVector3 pointOnB, [Const, Ref] btVector3 normalOnB, float distance, long lifeTime, [Const, Ref] btVector3 color);
  void reportErrorWarning([Const] DOMString warningString);
  void draw3dText([Const, Ref] btVector3 location, [Const] DOMString textString);
  void setDebugMode(long debugMode);
  long getDebugMode();
};

[JSImplementation="btIDebugDraw"]
interface DebugDrawer {
  void DebugDrawer();
  void drawLine([Const, Ref] btVector3 from, [Const, Ref] btVector3 to, [Const, Ref] btVector3 color);
  void drawContactPoint([Const, Ref] btVector3 pointOnB, [Const, Ref] btVector3 normalOnB, float distance, long lifeTime, [Const, Ref] btVector3 color);
  void reportErrorWarning([Const] DOMString warningString);
  void draw3dText([Const, Ref] btVector3 location, [Const] DOMString textString);
  void setDebugMode(long debugMode);
  [Const] long getDebugMode();
};

// Linear Math

interface btVector3 {
  void btVector3();
  void btVector3(float x, float y, float z);
  [Operator="+=", Ref] btVector3 op_add([Const, Ref] btVector3 v);
  [Operator="-=", Ref] btVector3 op_sub([Const, Ref] btVector3 v);
  [Operator="*=", Ref] btVector3 op_mul(float s);
  [Operator="/=", Ref] btVector3 op_div(float s);
  float dot([Const, Ref] btVector3 v);
  float length2();
  float length();
  float norm();
  float distance2([Const, Ref] btVector3 v);
  float distance([Const, Ref] btVector3 v);
  [Ref] btVector3 normalize();
  [Value] btVector3 normalized();
  [Value] btVector3 rotate([Const, Ref] btVector3 wAxis, float angle);
  float angle([Const, Ref] btVector3 v);
  [Value] btVector3 absolute();
  [Value] btVector3 cross([Const, Ref] btVector3 v);
  float triple([Const, Ref] btVector3 v1, [Const, Ref] btVector3 v2);
  long minAxis();
  long maxAxis();
  long furthestAxis();
  long closestAxis();
  void setInterpolate3([Const, Ref] btVector3 v0, [Const, Ref] btVector3 v1, float rt);
  [Value] btVector3 lerp([Const, Ref] btVector3 v, float t);
  [Operator="*=", Ref] btVector3 op_mulv([Const, Ref] btVector3 v);
  float getX();
  float getY();
  float getZ();
  void setX(float x);
  void setY(float y);
  void setZ(float z);
  void setW(float w);
  float x();
  float y();
  float z();
  float w();
  [Operator="=="] boolean op_eq([Const, Ref] btVector3 other);
  [Operator="!="] boolean op_neq([Const, Ref] btVector3 other);
  void setMax([Const, Ref] btVector3 other);
  void setMin([Const, Ref] btVector3 other);
  void setValue(float x, float y, float z);
  void getSkewSymmetricMatrix(btVector3 v0, btVector3 v1, btVector3 v2);
  void setZero();
  boolean isZero();
  boolean fuzzyZero();
  // long maxDot([Const] btVector3[] array, long array_count, [Ref] float dotOut);
  // long minDot([Const] btVector3[] array, long array_count, [Ref] float dotOut);
  [Value] btVector3 dot3([Const, Ref] btVector3 v0, [Const, Ref] btVector3 v1, [Const, Ref] btVector3 v2);
};

interface btVector4 {
  void btVector4();
  void btVector4(float x, float y, float z, float w);
  [Value] btVector4 absolute4();
  float getW();
  long maxAxis4();
  long minAxis4();
  long closestAxis4();
  void setValue(float x, float y, float z, float w);
};
btVector4 implements btVector3;

interface btQuadWord {
  void btQuadWord();
  void btQuadWord(float x, float y, float z, float w);
  float getX();
  float getY();
  float getZ();
  void setX(float x);
  void setY(float y);
  void setZ(float z);
  void setW(float w);
  float x();
  float y();
  float z();
  float w();
  [Operator="=="] boolean op_eq([Const, Ref] btQuadWord other);
  [Operator="!="] boolean op_neq([Const, Ref] btQuadWord other);
  void setValue(float x, float y, float z);
  void setValue(float x, float y, float z, float w);
  void setMax([Const, Ref] btQuadWord other);
  void setMin([Const, Ref] btQuadWord other);
};

interface btQuaternion {
  void btQuaternion();
  void btQuaternion(float x, float y, float z, float w);
  void btQuaternion([Const, Ref] btVector3 _axis, float _angle);
  void btQuaternion(float yaw, float pitch, float roll);
  void setRotation([Ref] btVector3 axis, float angle);
  void setEuler(float yaw, float pitch, float roll);
  void setEulerZYX(float yawZ, float pitchY, float rollX);
  [Operator="+=", Ref] btQuaternion op_add([Ref] btQuaternion q);
  [Operator="-=", Ref] btQuaternion op_sub([Ref] btQuaternion q);
  [Operator="*=", Ref] btQuaternion op_mul(float s);
  [Operator="*=", Ref] btQuaternion op_mulq([Ref] btQuaternion q);
  float dot([Const, Ref] btQuaternion q);
  float length2();
  float length();
  void normalize();
  [Operator="/=", Ref] btQuaternion op_div(float s);
  [Value] btQuaternion normalized();
  float angle([Const, Ref] btQuaternion q);
  float angleShortestPath([Const, Ref] btQuaternion q);
  float getAngle();
  float getAngleShortestPath();
  [Value] btVector3 getAxis();
  [Value] btQuaternion inverse();
  // [Value] btQuaternion farthest([Const, Ref] btQuaternion qd);
  // [Value] btQuaternion nearest([Const, Ref] btQuaternion qd);
  [Value] btQuaternion slerp([Const, Ref] btQuaternion q, float t);
  [Const, Ref] btQuaternion getIdentity();
  float getW();
};
btQuaternion implements btQuadWord;

interface btMatrix3x3 {
  void btMatrix3x3();
  void btMatrix3x3([Const, Ref] btQuaternion q);
  void btMatrix3x3(float xx, float xy, float xz,
    float yx, float yy, float yz,
    float zx, float zy, float zz);
  void btMatrix3x3([Const, Ref] btVector3 v0, [Const, Ref] btVector3 v1, [Const, Ref] btVector3 v2);
  [Value] btVector3 getColumn(long i);
  [Const, Ref] btVector3 getRow(long i);
  [Operator="[]", Ref] btVector3 op_id(long i);
  [Operator="*=", Ref] btMatrix3x3 op_mul([Const, Ref] btMatrix3x3 m);
  [Operator="+=", Ref] btMatrix3x3 op_add([Const, Ref] btMatrix3x3 m);
  [Operator="-=", Ref] btMatrix3x3 op_div([Const, Ref] btMatrix3x3 m);
  void setValue(float xx, float xy, float xz,
    float yx, float yy, float yz,
    float zx, float zy, float zz);
  void setRotation([Const, Ref] btQuaternion q);
  void setEulerYPR(float yaw, float pitch, float roll);
  void setEulerZYX(float eulerX, float eulerY, float eulerZ);
  void setIdentity();
  void setZero();
  [Const, Ref] btMatrix3x3 getIdentity();
  void getRotation([Ref] btQuaternion q);
  [Value] btMatrix3x3 scaled([Const, Ref] btVector3 s);
  float determinant();
  [Value] btMatrix3x3 adjoint();
  [Value] btMatrix3x3 absolute();
  [Value] btMatrix3x3 transpose();
  [Value] btMatrix3x3 inverse();
  [Value] btVector3 solve33([Const, Ref] btVector3 b);
  [Value] btMatrix3x3 transposeTimes([Const, Ref] btMatrix3x3 m);
  [Value] btMatrix3x3 timesTranspose([Const, Ref] btMatrix3x3 m);
  float tdotx([Const, Ref] btVector3 v);
  float tdoty([Const, Ref] btVector3 v);
  float tdotz([Const, Ref] btVector3 v);
  void extractRotation([Ref] btQuaternion q, optional float tolerance, optional long maxIter);
  void diagonalize([Ref] btMatrix3x3 rot, float threshold, long maxSteps);
  float cofac(long r1, long c1, long r2, long c2);
};

interface btTransform {
  void btTransform();
  void btTransform([Const, Ref] btQuaternion q, [Const, Ref] optional btVector3 v);
  [Operator="=", Ref] btTransform op_set([Const, Ref] btTransform other);
  void mult([Const, Ref] btTransform t1, [Const, Ref] btTransform t2);
  [Ref] btMatrix3x3 getBasis();
  [Ref] btVector3 getOrigin();
  [Value] btQuaternion getRotation();
  // void setFromOpenGLMatrix(float[] m);
  // void getOpenGLMatrix(float[] m);
  void setOrigin([Const, Ref] btVector3 origin);
  [Value] btVector3 invXform([Const, Ref] btVector3 inVec);
  void setBasis([Const, Ref] btMatrix3x3 basis);
  void setRotation([Const, Ref] btQuaternion q);
  void setIdentity();
  [Operator="*=", Ref] btTransform op_mul([Const, Ref] btTransform t);
  [Value] btTransform inverse();
  [Value] btTransform inverseTimes([Const, Ref] btTransform t);
  [Const, Ref] btTransform getIdentity();
};

interface btTypedObject {
  void btTypedObject(long objectType);
  attribute long m_objectType;
  long getObjectType();
};

interface btMotionState {
  void getWorldTransform([Ref] btTransform worldTrans);
  void setWorldTransform([Const, Ref] btTransform worldTrans);
};

interface btDefaultMotionState {
  void btDefaultMotionState([Const, Ref] optional btTransform startTrans, [Const, Ref] optional btTransform centerOfMassOffset);
  [Value] attribute btTransform m_graphicsWorldTrans;
  [Value] attribute btTransform m_centerOfMassOffset;
  [Value] attribute btTransform m_startWorldTrans;
  attribute VoidPtr m_userPointer;
  void getWorldTransform([Ref] btTransform centerOfMassWorldTrans);
  void setWorldTransform([Const, Ref] btTransform centerOfMassWorldTrans);
};
btDefaultMotionState implements btMotionState;

interface btIntArray {
  long size();
  long at(long n);
};

interface btFace {
  [Value] attribute btIntArray m_indices;
  attribute float[] m_plane;
};

interface btVector3Array {
  long size();
  [Const, Ref] btVector3 at(long n);
};

interface btFaceArray {
  long size();
  [Const, Ref] btFace at(long n);
};

// Collision

interface btCollisionObject {
  void btCollisionObject();
  boolean mergesSimulationIslands();
  [Const, Ref] btVector3 getAnisotropicFriction();
  void setAnisotropicFriction([Const, Ref] btVector3 anisotropicFriction, optional long frictionMode);
  boolean hasAnisotropicFriction(optional long frictionMode);
  void setContactProcessingThreshold(float contactProcessingThreshold);
  float getContactProcessingThreshold();
  boolean isStaticObject();
  boolean isKinematicObject();
  boolean isStaticOrKinematicObject();
  boolean hasContactResponse();
  void setCollisionShape(btCollisionShape collisionShape);
  btCollisionShape getCollisionShape();
  void setIgnoreCollisionCheck([Const] btCollisionObject co, boolean ignoreCollisionCheck);
  long getNumObjectsWithoutCollision();
  [Const] btCollisionObject getObjectWithoutCollision(long index);
  boolean checkCollideWithOverride([Const] btCollisionObject co);
  long getActivationState();
  void setActivationState(long newState);
  void setDeactivationTime(float time);
  float getDeactivationTime();
  void forceActivationState(long newState);
  void activate(optional boolean forceActivation);
  boolean isActive();
  void setRestitution(float rest);
  float getRestitution();
  void setFriction(float frict);
  float getFriction();
  void setRollingFriction(float frict);
  float getRollingFriction();
  void setSpinningFriction(float frict);
  float getSpinningFriction();
  void setContactStiffnessAndDamping(float stiffness, float damping);
  float getContactStiffness();
  float getContactDamping();
  [Ref] btTransform getWorldTransform();
  void setWorldTransform([Const, Ref] btTransform worldTrans);
  btBroadphaseProxy getBroadphaseHandle();
  void setBroadphaseHandle(btBroadphaseProxy handle);
  [Ref] btTransform getInterpolationWorldTransform();
  void setInterpolationWorldTransform([Const, Ref] btTransform trans);
  void setInterpolationLinearVelocity([Const, Ref] btVector3 linvel);
  void setInterpolationAngularVelocity([Const, Ref] btVector3 angvel);
  [Const, Ref] btVector3 getInterpolationLinearVelocity();
  [Const, Ref] btVector3 getInterpolationAngularVelocity();
  long getIslandTag();
  void setIslandTag(long tag);
  long getCompanionId();
  void setCompanionId(long id);
  long getWorldArrayIndex();
  // void setWorldArrayIndex(long ix); // internal
  float getHitFraction();
  void setHitFraction(float hitFraction);
  long getCollisionFlags();
  void setCollisionFlags(long flags);
  float getCcdSweptSphereRadius();
  void setCcdSweptSphereRadius(float radius);
  float getCcdMotionThreshold();
  void setCcdMotionThreshold(float ccdMotionThreshold);
  VoidPtr getUserPointer();
  long getUserIndex();
  long getUserIndex2();
  long getUserIndex3();
  void setUserPointer(VoidPtr userPointer);
  void setUserIndex(long index);
  void setUserIndex2(long index);
  void setUserIndex3(long index);
  long getUpdateRevisionInternal();
  boolean checkCollideWith([Const] btCollisionObject co);
};

[NoDelete]
interface btCollisionObjectWrapper {
  // readonly attribute btCollisionObjectWrapper m_parent;
  // readonly attribute btCollisionShape m_shape;
  // readonly attribute btCollisionObject m_collisionObject;
  // readonly attribute btTransform m_worldTransform;
  // readonly attribute btTransform m_preTransform;
  attribute long m_partId;
  attribute long m_index;
  [Const, Ref] btTransform getWorldTransform();
  [Const] btCollisionObject getCollisionObject();
  [Const] btCollisionShape getCollisionShape();
};

[Prefix="btCollisionWorld::"]
interface RayResultCallback {
  attribute float m_closestHitFraction;
  [Const] attribute btCollisionObject m_collisionObject;
  attribute short m_collisionFilterGroup;
  attribute short m_collisionFilterMask;
  attribute long m_flags;
  boolean hasHit();
  boolean needsCollision(btBroadphaseProxy proxy0);
};

[Prefix="btCollisionWorld::"]
interface LocalRayResult {
  void LocalRayResult([Const] btCollisionObject collisionObject,
    LocalShapeInfo localShapeInfo,
    [Const, Ref] btVector3 hitNormalLocal,
    float hitFraction);
  [Const] attribute btCollisionObject m_collisionObject;
  attribute LocalShapeInfo m_localShapeInfo;
  [Value] attribute btVector3 m_hitNormalLocal;
  attribute float m_hitFraction;
};

[Prefix="btCollisionWorld::"]
interface ClosestRayResultCallback {
  void ClosestRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);
  [Value] attribute btVector3 m_rayFromWorld;
  [Value] attribute btVector3 m_rayToWorld;
  [Value] attribute btVector3 m_hitNormalWorld;
  [Value] attribute btVector3 m_hitPointWorld;
  float addSingleResult([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
};
ClosestRayResultCallback implements RayResultCallback;

interface btConstCollisionObjectArray {
  long size();
  [Const] btCollisionObject at(long n);
};

interface btScalarArray {
  long size();
  float at(long n);
};

[Prefix="btCollisionWorld::"]
interface AllHitsRayResultCallback {
  void AllHitsRayResultCallback([Const, Ref] btVector3 from, [Const, Ref] btVector3 to);
  [Value] attribute btConstCollisionObjectArray m_collisionObjects;
  [Value] attribute btVector3 m_rayFromWorld;
  [Value] attribute btVector3 m_rayToWorld;
  [Value] attribute btVector3Array m_hitNormalWorld;
  [Value] attribute btVector3Array m_hitPointWorld;
  [Value] attribute btScalarArray m_hitFractions;
  float addSingleResult([Ref] LocalRayResult rayResult, boolean normalInWorldSpace);
};
AllHitsRayResultCallback implements RayResultCallback;

[Prefix="btCollisionWorld::"]
interface LocalConvexResult  {
  void LocalConvexResult([Const] btCollisionObject hitCollisionObject, LocalShapeInfo localShapeInfo, [Const, Ref] btVector3 hitNormalLocal, [Const, Ref] btVector3 hitPointLocal, float hitFraction);
  [Const] attribute btCollisionObject m_hitCollisionObject;
  attribute LocalShapeInfo m_localShapeInfo;
  [Value] attribute btVector3 m_hitNormalLocal;
  [Value] attribute btVector3 m_hitPointLocal;
  attribute float m_hitFraction;
};

interface btManifoldPoint {
  void btManifoldPoint();
  void btManifoldPoint([Const, Ref] btVector3 pointA, [Const, Ref] btVector3 pointB,
    [Const, Ref] btVector3 normal, float distance);
  [Value] attribute btVector3 m_localPointA;
  [Value] attribute btVector3 m_localPointB;
  [Value] attribute btVector3 m_positionWorldOnB;
  [Value] attribute btVector3 m_positionWorldOnA;
  [Value] attribute btVector3 m_normalWorldOnB;
  attribute float m_distance1;
  attribute float m_combinedFriction;
  attribute float m_combinedRollingFriction;   //torsional friction orthogonal to contact normal, useful to make spheres stop rolling forever
  attribute float m_combinedSpinningFriction;  //torsional friction around contact normal, useful for grasping objects
  attribute float m_combinedRestitution;
  attribute long m_partId0;
  attribute long m_partId1;
  attribute long m_index0;
  attribute long m_index1;
  attribute any m_userPersistentData; // Contact callback support
  attribute long m_contactPointFlags;
  attribute float m_appliedImpulse;
  attribute float m_prevRHS;
  attribute float m_appliedImpulseLateral1;
  attribute float m_appliedImpulseLateral2;
  attribute float m_contactMotion1;
  attribute float m_contactMotion2;
  attribute float m_frictionCFM;
  attribute long m_lifeTime;
  [Value] attribute btVector3 m_lateralFrictionDir1;
  [Value] attribute btVector3 m_lateralFrictionDir2;
  float getDistance();
  long getLifeTime();
  [Const, Ref] btVector3 getPositionWorldOnA();
  [Const, Ref] btVector3 getPositionWorldOnB();
  void setDistance(float dist);
  float getAppliedImpulse();
};

[Prefix="btCollisionWorld::"]
interface ContactResultCallback {
  // void ContactResultCallback();
  attribute long m_collisionFilterGroup;
  attribute long m_collisionFilterMask;
  attribute float m_closestDistanceThreshold;
  boolean needsCollision(btBroadphaseProxy proxy0);
  float addSingleResult([Ref] btManifoldPoint cp, [Const] btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const] btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
};

[JSImplementation="ContactResultCallback"]
interface ConcreteContactResultCallback {
  void ConcreteContactResultCallback();
  float addSingleResult([Ref] btManifoldPoint cp, [Const] btCollisionObjectWrapper colObj0Wrap, long partId0, long index0, [Const] btCollisionObjectWrapper colObj1Wrap, long partId1, long index1);
};

[Prefix="btCollisionWorld::"]
interface LocalShapeInfo {
  attribute long m_shapePart;
  attribute long m_triangleIndex;
};

[Prefix="btCollisionWorld::"]
interface ConvexResultCallback {
  // abstract base class, no constructor
  attribute float m_closestHitFraction;
  attribute long m_collisionFilterGroup;
  attribute long m_collisionFilterMask;
  boolean hasHit();
  boolean needsCollision(btBroadphaseProxy proxy0);
  float addSingleResult([Ref] LocalConvexResult convexResult, boolean normalInWorldSpace);
};

[Prefix="btCollisionWorld::"]
interface ClosestConvexResultCallback {
  void ClosestConvexResultCallback([Const, Ref] btVector3 convexFromWorld, [Const, Ref] btVector3 convexToWorld);
  [Value] attribute btVector3 m_convexFromWorld;
  [Value] attribute btVector3 m_convexToWorld;
  [Value] attribute btVector3 m_hitNormalWorld;
  [Value] attribute btVector3 m_hitPointWorld;
  [Const] attribute btCollisionObject m_hitCollisionObject;
  float addSingleResult([Ref] LocalConvexResult convexResult, boolean normalInWorldSpace);
};
ClosestConvexResultCallback implements ConvexResultCallback;

// Collision shapes

interface btCollisionShape {
  // abstract base class
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  float getAngularMotionDisc();
  float getContactBreakingThreshold(float defaultContactThresholdFactor);
  void calculateTemporalAabb([Const, Ref] btTransform curTrans, [Const, Ref] btVector3 linvel, [Const, Ref] btVector3 angvel, float timeStep, [Ref] btVector3 temporalAabbMin, [Ref] btVector3 temporalAabbMax);
  boolean isPolyhedral();
  boolean isConvex2d();
  boolean isConvex();
  boolean isNonMoving();
  boolean isConcave();
  boolean isCompound();
  boolean isSoftBody();
  boolean isInfinite();
  void setLocalScaling([Const, Ref] btVector3 scaling);
  [Const, Ref] btVector3 getLocalScaling();
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  [Const] DOMString getName();
  long getShapeType();
  [Value] btVector3 getAnisotropicRollingFrictionDirection();
  void setMargin(float margin);
  float getMargin();
  void setUserPointer(VoidPtr userPtr);
  VoidPtr getUserPointer();
  void setUserIndex(long index);
  long getUserIndex();
  void setUserIndex2(long index);
  long getUserIndex2();
};

interface btConvexShape {
  // abstract class
  [Value] btVector3 localGetSupportingVertex([Const, Ref] btVector3 vec);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  [Value] btVector3 localGetSupportVertexWithoutMarginNonVirtual([Const, Ref] btVector3 vec);
  [Value] btVector3 localGetSupportVertexNonVirtual([Const, Ref] btVector3 vec);
  float getMarginNonVirtual();
  void getAabbNonVirtual([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void project([Const, Ref] btTransform trans, [Const, Ref] btVector3 dir, float minProj, float maxProj, [Ref] btVector3 witnesPtMin, [Ref] btVector3 witnesPtMax);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void getAabbSlow([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void setLocalScaling([Const, Ref] btVector3 scaling);
  [Const, Ref] btVector3 getLocalScaling();
  void setMargin(float margin);
  float getMargin();
  long getNumPreferredPenetrationDirections();
  void getPreferredPenetrationDirection(long index, [Ref] btVector3 penetrationVector);
};
btConvexShape implements btCollisionShape;

interface btConvexInternalShape {
  [Value] btVector3 localGetSupportingVertex([Const, Ref] btVector3 vec);
  [Const, Ref] btVector3 getImplicitShapeDimensions();
  void setImplicitShapeDimensions([Const, Ref] btVector3 dimensions);
  void setSafeMargin(float minDimension, optional float defaultMarginMultiplier);
  // void setSafeMargin([Const, Ref] btVector3 halfExtents, optional float defaultMarginMultiplier);
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void getAabbSlow([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void setLocalScaling([Const, Ref] btVector3 scaling);
  void setMargin(float margin);
  float getMargin();
  long getNumPreferredPenetrationDirections();
  void getPreferredPenetrationDirection(long index, [Ref] btVector3 penetrationVector);
};
btConvexInternalShape implements btConvexShape;

interface btConvexInternalAabbCachingShape {
  void setLocalScaling([Const, Ref] btVector3 scaling);
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void recalcLocalAabb();
};
btConvexInternalAabbCachingShape implements btConvexInternalShape;

interface btConvexPolyhedron {
  void btConvexPolyhedron();
  [Value] attribute btVector3Array m_vertices;
  [Value] attribute btFaceArray m_faces;
  [Value] attribute btVector3Array m_uniqueEdges;
  [Value] attribute btVector3 m_localCenter;
  [Value] attribute btVector3 m_extents;
  attribute float m_radius;
  [Value] attribute btVector3 mC;
  [Value] attribute btVector3 mE;
  void initialize();
  void initialize2();
  boolean testContainment();
  // void project([Const, Ref] btTransform trans, [Const, Ref] btVector3 dir, [Ref] float minProj, [Ref] float maxProj, [Ref] btVector3 witnesPtMin, [Ref] btVector3 witnesPtMax);
};

interface btPolyhedralConvexShape {
  // abstract class
  boolean initializePolyhedralFeatures(optional long shiftVerticesByMargin);
  void setPolyhedralFeatures([Ref] btConvexPolyhedron polyhedron);
  [Const] btConvexPolyhedron getConvexPolyhedron();
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  long getNumVertices();
  long getNumEdges();
  void getEdge(long i, [Ref] btVector3 pa, [Ref] btVector3 pb);
  void getVertex(long i, [Ref] btVector3 vtx);
  long getNumPlanes();
  void getPlane([Ref] btVector3 planeNormal, [Ref] btVector3 planeSupport, long i);
  boolean isInside([Const, Ref] btVector3 pt, float tolerance);
};
btPolyhedralConvexShape implements btConvexInternalShape;

interface btPolyhedralConvexAabbCachingShape {
  // abstract class
  void setLocalScaling([Const, Ref] btVector3 scaling);
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void recalcLocalAabb();
};
btPolyhedralConvexAabbCachingShape implements btPolyhedralConvexShape;

interface btConvexTriangleMeshShape {
  void btConvexTriangleMeshShape(btStridingMeshInterface meshInterface, optional boolean calcAabb);
  btStridingMeshInterface getMeshInterface();
  [Value] btVector3 localGetSupportingVertex([Const, Ref] btVector3 vec);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  [Const] DOMString getName();
  long getNumVertices();
  long getNumEdges();
  void getEdge(long i, [Ref] btVector3 pa, [Ref] btVector3 pb);
  void getVertex(long i, [Ref] btVector3 vtx);
  long getNumPlanes();
  void getPlane([Ref] btVector3 planeNormal, [Ref] btVector3 planeSupport, long i);
  boolean isInside([Const, Ref] btVector3 pt, float tolerance);
  void setLocalScaling([Const, Ref] btVector3 scaling);
  [Const, Ref] btVector3 getLocalScaling();
  // void calculatePrincipalAxisTransform([Ref] btTransform principal, [Ref] btVector3 inertia, [Ref] float volume);
};
btConvexTriangleMeshShape implements btPolyhedralConvexAabbCachingShape;

interface btBoxShape {
  void btBoxShape([Const, Ref] btVector3 boxHalfExtents);
  [Value] btVector3 getHalfExtentsWithMargin();
  [Const, Ref] btVector3 getHalfExtentsWithoutMargin();
  [Value] btVector3 localGetSupportingVertex([Const, Ref] btVector3 vec);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  void setMargin(float collisionMargin);
  float getMargin();
  void setLocalScaling([Const, Ref] btVector3 scaling);
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  void getPlane([Ref] btVector3 planeNormal, [Ref] btVector3 planeSupport, long i);
  long getNumPlanes();
  long getNumVertices();
  long getNumEdges();
  void getVertex(long i, [Ref] btVector3 vtx);
  void getPlaneEquation([Ref] btVector4 plane, long i);
  void getEdge(long i, [Ref] btVector3 pa, [Ref] btVector3 pb);
  boolean isInside([Const, Ref] btVector3 pt, float tolerance);
  [Const] DOMString getName();
  long getNumPreferredPenetrationDirections();
  void getPreferredPenetrationDirection(long index, [Ref] btVector3 penetrationVector);
};
btBoxShape implements btPolyhedralConvexShape;

interface btCapsuleShape {
  void btCapsuleShape(float radius, float height);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  void setMargin(float collisionMargin);
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  [Const] DOMString getName();
  long getUpAxis();
  float getRadius();
  float getHalfHeight();
  void setLocalScaling([Const, Ref] btVector3 scaling);
  [Value] btVector3 getAnisotropicRollingFrictionDirection();
};
btCapsuleShape implements btConvexInternalShape;

interface btCapsuleShapeX {
  void btCapsuleShapeX(float radius, float height);
  [Const] DOMString getName();
};
btCapsuleShapeX implements btCapsuleShape;

interface btCapsuleShapeZ {
  void btCapsuleShapeZ(float radius, float height);
  [Const] DOMString getName();
};
btCapsuleShapeZ implements btCapsuleShape;

interface btCylinderShape {
  void btCylinderShape([Const, Ref] btVector3 halfExtents);
  [Value] btVector3 getHalfExtentsWithMargin();
  [Const, Ref] btVector3 getHalfExtentsWithoutMargin();
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  void setMargin(float margin);
  [Value] btVector3 localGetSupportingVertex([Const, Ref] btVector3 vec);
  long getUpAxis();
  [Value] btVector3 getAnisotropicRollingFrictionDirection();
  float getRadius();
  void setLocalScaling([Const, Ref] btVector3 scaling);
  [Const] DOMString getName();
  
};
btCylinderShape implements btConvexInternalShape;

interface btCylinderShapeX {
  void btCylinderShapeX([Ref] btVector3 halfExtents);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  [Const] DOMString getName();
  float getRadius();
};
btCylinderShapeX implements btCylinderShape;

interface btCylinderShapeZ {
  void btCylinderShapeZ([Ref] btVector3 halfExtents);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  [Const] DOMString getName();
  float getRadius();
};
btCylinderShapeZ implements btCylinderShape;

interface btSphereShape {
  void btSphereShape(float radius);
  [Value] btVector3 localGetSupportingVertex([Const, Ref] btVector3 vec);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  float getRadius();
  void setUnscaledRadius(float radius);
  [Const] DOMString getName();
  void setMargin(float margin);
  float getMargin();
};
btSphereShape implements btConvexInternalShape;

interface btMultiSphereShape {
  void btMultiSphereShape([Const] btVector3 positions, [Const] float[] radi, long numSpheres);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  long getSphereCount();
  [Const, Ref] btVector3 getSpherePosition(long index);
  float getSphereRadius(long index);
  [Const] DOMString getName();
  
};
btMultiSphereShape implements btConvexInternalAabbCachingShape;

interface btConeShape {
  void btConeShape(float radius, float height);
  [Value] btVector3 localGetSupportingVertex([Const, Ref] btVector3 vec);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  float getRadius();
  float getHeight();
  void setRadius(float radius);
  void setHeight(float height);
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  [Const] DOMString getName();
  void setConeUpIndex(long upIndex);
  long getConeUpIndex();
  [Value] btVector3 getAnisotropicRollingFrictionDirection();
  void setLocalScaling([Const, Ref] btVector3 scaling);
  
};
btConeShape implements btConvexInternalShape;

interface btConeShapeX {
  void btConeShapeX(float radius, float height);
  [Value] btVector3 getAnisotropicRollingFrictionDirection();
  [Const] DOMString getName();
};
btConeShapeX implements btConeShape;

interface btConeShapeZ {
  void btConeShapeZ(float radius, float height);
  [Value] btVector3 getAnisotropicRollingFrictionDirection();
  [Const] DOMString getName();
};
btConeShapeZ implements btConeShape;

interface btConvexHullShape {
  void btConvexHullShape([Const] optional float[] points, optional long numPoints, optional long stride);
  void addPoint([Const, Ref] btVector3 point, optional boolean recalculateLocalAABB);
  btVector3 getUnscaledPoints();
  [Const] btVector3 getPoints();
  void optimizeConvexHull();
  [Value] btVector3 getScaledPoint(long i);
  long getNumPoints();
  [Value] btVector3 localGetSupportingVertex([Const, Ref] btVector3 vec);
  [Value] btVector3 localGetSupportingVertexWithoutMargin([Const, Ref] btVector3 vec);
  void batchedUnitVectorGetSupportingVertexWithoutMargin([Const] btVector3 vectors, btVector3 supportVerticesOut, long numVectors);
  void project([Const, Ref] btTransform trans, [Const, Ref] btVector3 dir, float minProj, float maxProj, [Ref] btVector3 witnesPtMin, [Ref] btVector3 witnesPtMax);
  [Const] DOMString getName();
  long getNumVertices();
  long getNumEdges();
  void getEdge(long i, [Ref] btVector3 pa, [Ref] btVector3 pb);
  void getVertex(long i, [Ref] btVector3 vtx);
  long getNumPlanes();
  void getPlane([Ref] btVector3 planeNormal, [Ref] btVector3 planeSupport, long i);
  boolean isInside([Const, Ref] btVector3 pt, float tolerance);
  void setLocalScaling([Const, Ref] btVector3 scaling);
  
};
btConvexHullShape implements btPolyhedralConvexAabbCachingShape;

interface btShapeHull {
  void btShapeHull([Const] btConvexShape shape);
  boolean buildHull(float margin, optional long highres);
  long numTriangles();
  long numVertices();
  long numIndices();
  [Const] btVector3[] getVertexPointer();
  // [Const] unsigned long[] getIndexPointer();
};

interface btCompoundShapeChild {
  [Value] attribute btTransform m_transform;
  attribute btCollisionShape m_childShape;
  attribute long m_childShapeType;
  attribute float m_childMargin;
  attribute btDbvtNode m_node;
};

interface btCompoundShape {
  void btCompoundShape(optional boolean enableDynamicAabbTree, optional long initialChildCapacity);
  void addChildShape([Const, Ref] btTransform localTransform, btCollisionShape shape);
  void removeChildShape(btCollisionShape shape);
  void removeChildShapeByIndex(long childShapeindex);
  long getNumChildShapes();
  btCollisionShape getChildShape(long index);
  [Ref] btTransform getChildTransform(long index);
  void updateChildTransform(long childIndex, [Const, Ref] btTransform newChildTransform, optional boolean shouldRecalculateLocalAabb);
  btCompoundShapeChild[] getChildList();
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void recalculateLocalAabb();
  void setLocalScaling([Const, Ref] btVector3 scaling);
  [Const, Ref] btVector3 getLocalScaling();
  void calculateLocalInertia(float mass, [Ref] btVector3 inertia);
  void setMargin(float margin);
  float getMargin();
  [Const] DOMString getName();
  btDbvt getDynamicAabbTree();
  void createAabbTreeFromChildren();
  void calculatePrincipalAxisTransform(float[] masses, [Ref] btTransform principal, [Ref] btVector3 inertia);
  long getUpdateRevision();
  
};
btCompoundShape implements btCollisionShape;

interface btInternalTriangleIndexCallback {
  void internalProcessTriangleIndex(btVector3 triangle, long partId, long triangleIndex);
};

interface btStridingMeshInterface {
  // abstract base class
  void InternalProcessAllTriangles(btInternalTriangleIndexCallback callback, [Const, Ref] btVector3 aabbMin, [Const, Ref] btVector3 aabbMax);
  void setScaling([Const, Ref] btVector3 scaling);
};

interface btIndexedMesh {
  attribute long m_numTriangles;
  attribute long m_triangleIndexStride;
  attribute long m_numVertices;
  attribute long m_vertexStride;
  attribute PHY_ScalarType m_indexType;
  attribute PHY_ScalarType m_vertexType;
};

interface btIndexedMeshArray {
  long size();
  [Const, Ref] btIndexedMesh at(long n);
};

interface btTriangleIndexVertexArray {
  void btTriangleIndexVertexArray();
  void btTriangleIndexVertexArray(long numTriangles, long[] triangleIndexBase, long triangleIndexStride, long numVertices, float[] vertexBase, long vertexStride);
  void addIndexedMesh([Const, Ref] btIndexedMesh mesh, optional PHY_ScalarType indexType);
  // void getLockedVertexIndexBase(unsigned char** vertexbase, int& numverts, PHY_ScalarType& type, int& vertexStride, unsigned char** indexbase, int& indexstride, int& numfaces, PHY_ScalarType& indicestype, int subpart = 0);
  void unLockVertexBase(long subpart);
  void unLockReadOnlyVertexBase(long subpart);
  long getNumSubParts();
  [Ref] btIndexedMeshArray getIndexedMeshArray();
  void preallocateVertices(long numverts);
  void preallocateIndices(long numverts);
  boolean hasPremadeAabb();
  void setPremadeAabb([Const, Ref] btVector3 aabbMin, [Const, Ref] btVector3 aabbMax);
  void getPremadeAabb(btVector3 aabbMin, btVector3 aabbMax);
};
btTriangleIndexVertexArray implements btStridingMeshInterface;

interface btTriangleMesh {
  void btTriangleMesh(optional boolean use32bitIndices, optional boolean use4componentVertices);
  attribute float m_weldingThreshold;
  boolean getUse32bitIndices();
  boolean getUse4componentVertices();
  void addTriangle([Const, Ref] btVector3 vertex0, [Const, Ref] btVector3 vertex1, [Const, Ref] btVector3 vertex2, optional boolean removeDuplicateVertices);
  void addTriangleIndices(long index1, long index2, long index3);
  void preallocateVertices(long numverts);
  void preallocateIndices(long numverts);
  long findOrAddVertex([Const, Ref] btVector3 vertex, boolean removeDuplicateVertices);
  void addIndex(long index);
};
btTriangleMesh implements btTriangleIndexVertexArray;

enum PHY_ScalarType {
  "PHY_FLOAT",
  "PHY_DOUBLE",
  "PHY_INTEGER",
  "PHY_SHORT",
  "PHY_FIXEDPOINT88",
  "PHY_UCHAR"
};

interface btConcaveShape {
  // abstract base class
  float getMargin();
  void setMargin(float collisionMargin);
};
btConcaveShape implements btCollisionShape;

interface btEmptyShape {
  void btEmptyShape();
  void getAabb([Const, Ref] btTransform t, [Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  void setLocalScaling([Const, Ref] btVector3 scaling);
  [Const, Ref] btVector3 getLocalScaling();
};
btEmptyShape implements btConcaveShape;

interface btStaticPlaneShape {
  void btStaticPlaneShape([Const, Ref] btVector3 planeNormal, float planeConstant);
  [Const, Ref] btVector3 getPlaneNormal();
  float getPlaneConstant();
};
btStaticPlaneShape implements btConcaveShape;

interface btTriangleMeshShape {
  // internal class
};
btTriangleMeshShape implements btConcaveShape;

interface btBvhTriangleMeshShape {
  void btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, optional boolean buildBvh);
  void btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, boolean useQuantizedAabbCompression, [Const, Ref] btVector3 bvhAabbMin, [Const, Ref] btVector3 bvhAabbMax, optional boolean buildBvh);
};
btBvhTriangleMeshShape implements btTriangleMeshShape;

interface btHeightfieldTerrainShape {
    void btHeightfieldTerrainShape(long heightStickWidth, long heightStickLength, VoidPtr heightfieldData, float heightScale, float minHeight, float maxHeight, long upAxis, PHY_ScalarType hdt, boolean flipQuadEdges);
};
btHeightfieldTerrainShape implements btConcaveShape;

interface btDefaultCollisionConstructionInfo {
  void btDefaultCollisionConstructionInfo();
};

interface btDefaultCollisionConfiguration {
  void btDefaultCollisionConfiguration([Ref] optional btDefaultCollisionConstructionInfo info);
};

interface btPersistentManifold {
  void btPersistentManifold();
  [Const] btCollisionObject getBody0();
  [Const] btCollisionObject getBody1();
  long getNumContacts();
  [Ref] btManifoldPoint getContactPoint(long index);
};

interface btDispatcher {
  long getNumManifolds();
  btPersistentManifold getManifoldByIndexInternal(long index);
};

interface btCollisionDispatcher {
  void btCollisionDispatcher(btDefaultCollisionConfiguration conf);
};
btCollisionDispatcher implements btDispatcher;

interface btOverlappingPairCallback {
};

interface btOverlappingPairCache {
  void setInternalGhostPairCallback(btOverlappingPairCallback ghostPairCallback);
  [Const] float getNumOverlappingPairs();
};

interface btAxisSweep3 {
  void btAxisSweep3([Ref] btVector3 worldAabbMin, [Ref] btVector3 worldAabbMax, optional long maxHandles, optional btOverlappingPairCache pairCache, optional boolean disableRaycastAccelerator);
};

interface btBroadphaseInterface {
  btOverlappingPairCache getOverlappingPairCache();
};

interface btCollisionConfiguration {
};

interface btDbvt {};

interface btDbvtBroadphase {
  void btDbvtBroadphase();
};

interface btBroadphaseProxy {
  attribute long m_collisionFilterGroup;
  attribute long m_collisionFilterMask;
};

interface btDbvtVolume {};

interface btDbvtNode {
  [Value] attribute btDbvtVolume volume;
  attribute btDbvtNode parent;
  boolean isleaf();
  boolean isinternal();
};

// Dynamics

[Prefix="btRigidBody::"]
interface btRigidBodyConstructionInfo {
  void btRigidBodyConstructionInfo(float mass, btMotionState motionState, btCollisionShape collisionShape, [Ref] optional btVector3 localInertia);
  attribute float m_linearDamping;
  attribute float m_angularDamping;
  attribute float m_friction;
  attribute float m_rollingFriction;
  attribute float m_restitution;
  attribute float m_linearSleepingThreshold;
  attribute float m_angularSleepingThreshold;
  attribute boolean m_additionalDamping;
  attribute float m_additionalDampingFactor;
  attribute float m_additionalLinearDampingThresholdSqr;
  attribute float m_additionalAngularDampingThresholdSqr;
  attribute float m_additionalAngularDampingFactor;
};

interface btRigidBody {
  void btRigidBody([Const, Ref] btRigidBodyConstructionInfo constructionInfo);
  void proceedToTransform([Const, Ref] btTransform newTrans);
  btRigidBody upcast(btCollisionObject colObj);
  void predictIntegratedTransform(float step, [Ref] btTransform predictedTransform);
  void saveKinematicState(float step);
  void applyGravity();
  void clearGravity();
  void setGravity([Const, Ref] btVector3 acceleration);
  [Const, Ref] btVector3 getGravity();
  void setDamping(float lin_damping, float ang_damping);
  [Const] float getLinearDamping();
  [Const] float getAngularDamping();
  float getLinearSleepingThreshold();
  float getAngularSleepingThreshold();
  void applyDamping(float timeStep);
  btCollisionShape getCollisionShape();
  void setMassProps(float mass, [Const, Ref] btVector3 inertia);
  [Const, Ref] btVector3 getLinearFactor();
  void setLinearFactor([Const, Ref] btVector3 linearFactor);
  float getInvMass();
  float getMass();
  [Const, Ref] btMatrix3x3 getInvInertiaTensorWorld();
  void integrateVelocities(float step);
  void setCenterOfMassTransform([Const, Ref] btTransform xform);
  void applyCentralForce([Const, Ref] btVector3 force);
  [Const, Ref] btVector3 getTotalForce();
  [Const, Ref] btVector3 getTotalTorque();
  [Const, Ref] btVector3 getInvInertiaDiagLocal();
  void setInvInertiaDiagLocal([Const, Ref] btVector3 diagInvInertia);
  void setSleepingThresholds(float linear, float angular);
  void applyTorque([Const, Ref] btVector3 torque);
  void applyForce([Const, Ref] btVector3 force, [Const, Ref] btVector3 rel_pos);
  void applyCentralImpulse([Const, Ref] btVector3 impulse);
  void applyTorqueImpulse([Const, Ref] btVector3 torque);
  void applyImpulse([Const, Ref] btVector3 impulse, [Const, Ref] btVector3 rel_pos);
  void applyPushImpulse([Const, Ref] btVector3 impulse, [Const, Ref] btVector3 rel_pos);
  [Value] btVector3 getPushVelocity();
  [Value] btVector3 getTurnVelocity();
  void setPushVelocity([Const, Ref] btVector3 v);
  void setTurnVelocity([Const, Ref] btVector3 v);
  void applyCentralPushImpulse([Const, Ref] btVector3 impulse);
  void applyTorqueTurnImpulse([Const, Ref] btVector3 torque);
  void clearForces();
  void updateInertiaTensor();
  [Const, Ref] btVector3 getCenterOfMassPosition();
  [Value] btQuaternion getOrientation();
  [Const, Ref] btTransform getCenterOfMassTransform();
  [Const, Ref] btVector3 getLinearVelocity();
  [Const, Ref] btVector3 getAngularVelocity();
  void setLinearVelocity([Const, Ref] btVector3 lin_vel);
  void setAngularVelocity([Const, Ref] btVector3 ang_vel);
  [Value] btVector3 getVelocityInLocalPoint([Const, Ref] btVector3 rel_pos);
  [Value] btVector3 getPushVelocityInLocalPoint([Const, Ref] btVector3 rel_pos);
  void translate([Const, Ref] btVector3 v);
  void getAabb([Ref] btVector3 aabbMin, [Ref] btVector3 aabbMax);
  float computeImpulseDenominator([Const, Ref] btVector3 pos, [Const, Ref] btVector3 normal);
  float computeAngularImpulseDenominator([Const, Ref] btVector3 axis);
  void updateDeactivation(float timeStep);
  boolean wantsSleeping();
  [Const] btBroadphaseProxy getBroadphaseProxy(); // const ? non-const
  void setNewBroadphaseProxy(btBroadphaseProxy broadphaseProxy);
  btMotionState getMotionState(); // const ? non-const
  void setMotionState(btMotionState motionState);
  void setAngularFactor([Const, Ref] btVector3 angFac);
  // void setAngularFactor(float angFac);
  [Const, Ref] btVector3 getAngularFactor();
  boolean isInWorld();
  void addConstraintRef(btTypedConstraint c);
  void removeConstraintRef(btTypedConstraint c);
  btTypedConstraint getConstraintRef(long index);
  long getNumConstraintRefs();
  void setFlags(long flags);
  long getFlags();
  [Value] btVector3 computeGyroscopicImpulseImplicit_World(float dt);
  [Value] btVector3 computeGyroscopicImpulseImplicit_Body(float step);
  [Value] btVector3 computeGyroscopicForceExplicit(float maxGyroscopicForce);
  [Value] btVector3 getLocalInertia();
};
btRigidBody implements btCollisionObject;

// Constraints

interface btSequentialImpulseConstraintSolver {
  void btSequentialImpulseConstraintSolver();
  void reset();
  void setRandSeed(unsigned long seed);
  unsigned long getRandSeed();
};

enum btTypedConstraintType {
  "POINT2POINT_CONSTRAINT_TYPE",
  "HINGE_CONSTRAINT_TYPE",
  "CONETWIST_CONSTRAINT_TYPE",
  "D6_CONSTRAINT_TYPE",
  "SLIDER_CONSTRAINT_TYPE",
  "CONTACT_CONSTRAINT_TYPE", // internal
  "D6_SPRING_CONSTRAINT_TYPE",
  "GEAR_CONSTRAINT_TYPE",
  "FIXED_CONSTRAINT_TYPE",
  "D6_SPRING_2_CONSTRAINT_TYPE",
  "MAX_CONSTRAINT_TYPE"
};

enum btConstraintParams {
  "BT_CONSTRAINT_ERP",
  "BT_CONSTRAINT_STOP_ERP",
  "BT_CONSTRAINT_CFM",
  "BT_CONSTRAINT_STOP_CFM"
};

interface btJointFeedback {
  [Value] attribute btVector3 m_appliedForceBodyA;
  [Value] attribute btVector3 m_appliedTorqueBodyA;
  [Value] attribute btVector3 m_appliedForceBodyB;
  [Value] attribute btVector3 m_appliedTorqueBodyB;
};

interface btTypedConstraint {
  [Ref] btRigidBody getFixedBody();
  long getOverrideNumSolverIterations();
  void setOverrideNumSolverIterations(long overideNumIterations);
  float getBreakingImpulseThreshold();
  void setBreakingImpulseThreshold([Const] float threshold);
  boolean isEnabled();
  void setEnabled(boolean enabled);
  [Const, Ref] btRigidBody getRigidBodyA();
  [Const, Ref] btRigidBody getRigidBodyB();
  long getUserConstraintType();
  void setUserConstraintType(long userConstraintType);
  void setUserConstraintId(long uid);
  long getUserConstraintId();
  void setUserConstraintPtr(VoidPtr ptr);
  VoidPtr getUserConstraintPtr();
  void setJointFeedback(btJointFeedback jointFeedback);
  btJointFeedback getJointFeedback();
  long getUid();
  boolean needsFeedback();
  void enableFeedback(boolean needsFeedback);
  float getAppliedImpulse();
  btTypedConstraintType getConstraintType();
  void setParam(long num, float value, long axis);
  float getParam(long num, long axis);
};
btTypedConstraint implements btTypedObject;

interface btConstraintSetting {
  void btConstraintSetting();
  attribute float m_tau;
  attribute float m_damping;
  attribute float m_impulseClamp;
};

enum btPoint2PointFlags {
  "BT_P2P_FLAGS_ERP",
  "BT_P2P_FLAGS_CFM"
};

interface btPoint2PointConstraint {
  void btPoint2PointConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btVector3 pivotInA, [Const, Ref] btVector3 pivotInB);
  void btPoint2PointConstraint([Ref] btRigidBody rbA, [Const, Ref] btVector3 pivotInA);
  [Value] attribute btConstraintSetting m_setting;
  void buildJacobian();
  void updateRHS(float timeStep);
  void setPivotA([Const, Ref] btVector3 pivotA);
  void setPivotB([Const, Ref] btVector3 pivotB);
  [Const, Ref] btVector3 getPivotInA();
  [Const, Ref] btVector3 getPivotInB();
  void setParam(long num, float value, optional long axis);
  float getParam(long num, optional long axis);
  long getFlags();
};
btPoint2PointConstraint implements btTypedConstraint;

interface btAngularLimit {
  void btAngularLimit();
  void set(float low, float high, optional float _softness, optional float _biasFactor, optional float _relaxationFactor);
  float getSoftness();
  float getBiasFactor();
  float getRelaxationFactor();
  float getCorrection();
  float getSign();
  float getHalfRange();
  boolean isLimit();
  void fit([Ref] float[] angle);
  float getError();
  float getLow();
  float getHigh();
};

enum btHingeFlags {
  "BT_HINGE_FLAGS_CFM_STOP",
  "BT_HINGE_FLAGS_ERP_STOP",
  "BT_HINGE_FLAGS_CFM_NORM",
  "BT_HINGE_FLAGS_ERP_NORM"
};

interface btHingeConstraint {
  void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btVector3 pivotInA, [Const, Ref] btVector3 pivotInB, [Const, Ref] btVector3 axisInA, [Const, Ref] btVector3 axisInB, optional boolean useReferenceFrameA);
  // void btHingeConstraint ([Ref] btRigidBody rbA, [Const, Ref] btVector3 pivotInA, [Const, Ref] btVector3 axisInA, optional boolean useReferenceFrameA);
  void btHingeConstraint ([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btTransform rbAFrame, [Const, Ref] btTransform rbBFrame, optional boolean useReferenceFrameA);
  void btHingeConstraint ([Ref] btRigidBody rbA, [Const, Ref] btTransform rbAFrame, optional boolean useReferenceFrameA);
  void buildJacobian();
  void updateRHS(float timeStep);
  [Const, Ref] btRigidBody getRigidBodyA();
  [Const, Ref] btRigidBody getRigidBodyB();
  [Ref] btTransform getFrameOffsetA();
  [Ref] btTransform getFrameOffsetB();
  void setFrames([Const, Ref] btTransform frameA, [Const, Ref] btTransform frameB);
  void setAngularOnly(boolean angularOnly);
  void enableAngularMotor(boolean enableMotor, float targetVelocity, float maxMotorImpulse);
  void enableMotor(boolean enableMotor);
  void setMaxMotorImpulse(float maxMotorImpulse);
  void setMotorTargetVelocity(float motorTargetVelocity);
  // void setMotorTarget([Const,Ref] btQuaternion qAinB, float dt);
  void setMotorTarget(float targetAngle, float dt);
  void setLimit(float low, float high, float softness, float biasFactor, optional float relaxationFactor);
  float getLimitSoftness();
  float getLimitBiasFactor();
  float getLimitRelaxationFactor();
  void setAxis([Ref] btVector3 axisInA);
  boolean hasLimit();
  float getLowerLimit();
  float getUpperLimit();
  float getHingeAngle();
  float getHingeAngle([Const, Ref] btTransform transA, [Const, Ref] btTransform transB);
  void testLimit([Const, Ref] btTransform transA, [Const, Ref] btTransform transB);
  [Const, Ref] btTransform getAFrame();
  [Const, Ref] btTransform getBFrame();
  long getSolveLimit();
  float getLimitSign();
  boolean getAngularOnly();
  boolean getEnableAngularMotor();
  float getMotorTargetVelocity();
  float getMaxMotorImpulse();
  boolean getUseFrameOffset();
  void setUseFrameOffset(boolean frameOffsetOnOff);
  boolean getUseReferenceFrameA();
  void setUseReferenceFrameA(boolean useReferenceFrameA);
  void setParam(long num, float value, optional long axis);
  float getParam(long num, optional long axis);
  long getFlags();
};
btHingeConstraint implements btTypedConstraint;

enum btConeTwistFlags {
  "BT_CONETWIST_FLAGS_LIN_CFM",
  "BT_CONETWIST_FLAGS_LIN_ERP",
  "BT_CONETWIST_FLAGS_ANG_CFM"
};

interface btConeTwistConstraint {
  void btConeTwistConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btTransform rbAFrame, [Const, Ref] btTransform rbBFrame);
  void btConeTwistConstraint([Ref] btRigidBody rbA, [Const, Ref] btTransform rbAFrame);
  void buildJacobian();
  void updateRHS(float timeStep);
  [Const, Ref] btRigidBody getRigidBodyA();
  [Const, Ref] btRigidBody getRigidBodyB();
  void setAngularOnly(boolean angularOnly);
  boolean getAngularOnly();
  void setLimit(long limitIndex, float limitValue);
  float getLimit(long limitIndex);
  void setLimit(float _swingSpan1, float _swingSpan2, float _twistSpan, optional float _softness, optional float _biasFactor, optional float _relaxationFactor);
  [Const, Ref] btTransform getAFrame();
  [Const, Ref] btTransform getBFrame();
  long getSolveTwistLimit();
  long getSolveSwingLimit();
  float getTwistLimitSign();
  void calcAngleInfo();
  void calcAngleInfo2([Const, Ref] btTransform transA, [Const, Ref] btTransform transB, [Const, Ref] btMatrix3x3 invInertiaWorldA, [Const, Ref] btMatrix3x3 invInertiaWorldB);
  float getSwingSpan1();
  float getSwingSpan2();
  float getTwistSpan();
  float getLimitSoftness();
  float getBiasFactor();
  float getRelaxationFactor();
  float getTwistAngle();
  boolean isPastSwingLimit();
  float getDamping();
  void setDamping(float damping);
  void enableMotor(boolean b);
  boolean isMotorEnabled();
  float getMaxMotorImpulse();
  boolean isMaxMotorImpulseNormalized();
  void setMaxMotorImpulse(float maxMotorImpulse);
  void setMaxMotorImpulseNormalized(float maxMotorImpulse);
  float getFixThresh();
  void setFixThresh(float fixThresh);
  void setMotorTarget([Const,Ref] btQuaternion q);
  [Const,Ref] btQuaternion getMotorTarget();
  void setMotorTargetInConstraintSpace([Const,Ref] btQuaternion q);
  [Value] btVector3 GetPointForAngle(float fAngleInRadians, float fLength);
  void setParam(long num, float value, optional long axis);
  [Const, Ref] btTransform getFrameOffsetA();
  [Const, Ref] btTransform getFrameOffsetB();
  float getParam(long num, optional long axis);
  long getFlags();
};
btConeTwistConstraint implements btTypedConstraint;

interface btRotationalLimitMotor {
  void btRotationalLimitMotor();
  attribute float m_loLimit;
  attribute float m_hiLimit;
  attribute float m_targetVelocity;
  attribute float m_maxMotorForce;
  attribute float m_maxLimitForce;
  attribute float m_damping;
  attribute float m_limitSoftness;
  attribute float m_normalCFM;
  attribute float m_stopERP;
  attribute float m_stopCFM;
  attribute float m_bounce;
  attribute boolean m_enableMotor;
  attribute float m_currentLimitError;
  attribute float m_currentPosition;
  attribute long m_currentLimit;
  attribute float m_accumulatedImpulse;
  boolean isLimited();
  boolean needApplyTorques();
  long testLimitValue(float test_value);
  float solveAngularLimits(float timeStep, [Ref] btVector3 axis, float jacDiagABInv, btRigidBody body0, btRigidBody body1);
};

interface btTranslationalLimitMotor {
  void btTranslationalLimitMotor();
  [Value] attribute btVector3 m_lowerLimit;
  [Value] attribute btVector3 m_upperLimit;
  [Value] attribute btVector3 m_accumulatedImpulse;
  attribute float m_limitSoftness;
  attribute float m_damping;
  attribute float m_restitution;
  [Value] attribute btVector3 m_normalCFM;
  [Value] attribute btVector3 m_stopERP;
  [Value] attribute btVector3 m_stopCFM;
  attribute boolean[] m_enableMotor;
  [Value] attribute btVector3 m_targetVelocity;
  [Value] attribute btVector3 m_maxMotorForce;
  [Value] attribute btVector3 m_currentLimitError;
  [Value] attribute btVector3 m_currentLinearDiff;
  attribute long[] m_currentLimit; 
  boolean isLimited(long limitIndex);
  boolean needApplyForce(long limitIndex);
  long testLimitValue(long limitIndex, float test_value);
  float solveLinearAxis(
    float timeStep,
    float jacDiagABInv,
    [Ref] btRigidBody body1, [Const, Ref] btVector3 pointInA,
    [Ref] btRigidBody body2, [Const, Ref] btVector3 pointInB,
    long limit_index,
    [Const, Ref] btVector3 axis_normal_on_a,
    [Const, Ref] btVector3 anchorPos);
};

enum bt6DofFlags {
  "BT_6DOF_FLAGS_CFM_NORM",
  "BT_6DOF_FLAGS_CFM_STOP",
  "BT_6DOF_FLAGS_ERP_STOP"
};

interface btGeneric6DofConstraint {
  void btGeneric6DofConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btTransform frameInA, [Const, Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameA);
  void btGeneric6DofConstraint([Ref] btRigidBody rbB, [Const, Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameB);
  void calculateTransforms([Const, Ref] btTransform transA, [Const, Ref] btTransform transB);
  void calculateTransforms();
  [Const, Ref] btTransform getCalculatedTransformA();
  [Const, Ref] btTransform getCalculatedTransformB();
  [Ref] btTransform getFrameOffsetA();
  [Ref] btTransform getFrameOffsetB();
  void buildJacobian();
  void updateRHS(float timeStep);
  [Value] btVector3 getAxis(long axis_index);
  float getAngle(long axis_index);
  float getRelativePivotPosition(long axis_index);
  void setFrames([Const, Ref] btTransform frameA, [Const, Ref] btTransform frameB);
  void setLinearLowerLimit([Const, Ref] btVector3 linearLower);
  void getLinearLowerLimit([Ref] btVector3 linearLower);
  void setLinearUpperLimit([Const, Ref] btVector3 linearUpper);
  void getLinearUpperLimit([Ref] btVector3 linearUpper);
  void setAngularLowerLimit([Const, Ref] btVector3 angularLower);
  void getAngularLowerLimit([Ref] btVector3 angularLower);
  void setAngularUpperLimit([Const, Ref] btVector3 angularUpper);
  void getAngularUpperLimit([Ref] btVector3 angularUpper);
  btRotationalLimitMotor getRotationalLimitMotor(long index);
  btTranslationalLimitMotor getTranslationalLimitMotor();
  void setLimit(long axis, float lo, float hi);
  boolean isLimited(long limitIndex);
  void calcAnchorPos();
  boolean getUseFrameOffset();
  void setUseFrameOffset(boolean frameOffsetOnOff);
  boolean getUseLinearReferenceFrameA();
  void setUseLinearReferenceFrameA(boolean linearReferenceFrameA);
  void setParam(long num, float value, optional long axis);
  float getParam(long num, optional long axis);
  void setAxis([Const, Ref] btVector3 axis1, [Const, Ref] btVector3 axis2);
  long getFlags();
};
btGeneric6DofConstraint implements btTypedConstraint;

enum btSliderFlags {
  "BT_SLIDER_FLAGS_CFM_DIRLIN",
  "BT_SLIDER_FLAGS_ERP_DIRLIN",
  "BT_SLIDER_FLAGS_CFM_DIRANG",
  "BT_SLIDER_FLAGS_ERP_DIRANG",
  "BT_SLIDER_FLAGS_CFM_ORTLIN",
  "BT_SLIDER_FLAGS_ERP_ORTLIN",
  "BT_SLIDER_FLAGS_CFM_ORTANG",
  "BT_SLIDER_FLAGS_ERP_ORTANG",
  "BT_SLIDER_FLAGS_CFM_LIMLIN",
  "BT_SLIDER_FLAGS_ERP_LIMLIN",
  "BT_SLIDER_FLAGS_CFM_LIMANG",
  "BT_SLIDER_FLAGS_ERP_LIMANG"
};

interface btSliderConstraint {
  void btSliderConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btTransform frameInA, [Const, Ref] btTransform frameInB, boolean useLinearReferenceFrameA);
  void btSliderConstraint([Ref] btRigidBody rbB, [Const, Ref] btTransform frameInB, boolean useLinearReferenceFrameA);
  [Const, Ref] btRigidBody getRigidBodyA();
  [Const, Ref] btRigidBody getRigidBodyB();
  [Const, Ref] btTransform getCalculatedTransformA();
  [Const, Ref] btTransform getCalculatedTransformB();
  [Const, Ref] btTransform getFrameOffsetA();
  [Const, Ref] btTransform getFrameOffsetB();
  float getLowerLinLimit();
  void setLowerLinLimit(float lowerLimit);
  float getUpperLinLimit();
  void setUpperLinLimit(float upperLimit);
  float getLowerAngLimit();
  void setLowerAngLimit(float lowerAngLimit);
  float getUpperAngLimit();
  void setUpperAngLimit(float upperAngLimit);
  boolean getUseLinearReferenceFrameA();
  float getSoftnessDirLin();
  float getRestitutionDirLin();
  float getDampingDirLin();
  float getSoftnessDirAng();
  float getRestitutionDirAng();
  float getDampingDirAng();
  float getSoftnessLimLin();
  float getRestitutionLimLin();
  float getDampingLimLin();
  float getSoftnessLimAng();
  float getRestitutionLimAng();
  float getDampingLimAng();
  float getSoftnessOrthoLin();
  float getRestitutionOrthoLin();
  float getDampingOrthoLin();
  float getSoftnessOrthoAng();
  float getRestitutionOrthoAng();
  float getDampingOrthoAng();
  void setSoftnessDirLin(float softnessDirLin);
  void setRestitutionDirLin(float restitutionDirLin);
  void setDampingDirLin(float dampingDirLin);
  void setSoftnessDirAng(float softnessDirAng);
  void setRestitutionDirAng(float restitutionDirAng);
  void setDampingDirAng(float dampingDirAng);
  void setSoftnessLimLin(float softnessLimLin);
  void setRestitutionLimLin(float restitutionLimLin);
  void setDampingLimLin(float dampingLimLin);
  void setSoftnessLimAng(float softnessLimAng);
  void setRestitutionLimAng(float restitutionLimAng);
  void setDampingLimAng(float dampingLimAng);
  void setSoftnessOrthoLin(float softnessOrthoLin);
  void setRestitutionOrthoLin(float restitutionOrthoLin);
  void setDampingOrthoLin(float dampingOrthoLin);
  void setSoftnessOrthoAng(float softnessOrthoAng);
  void setRestitutionOrthoAng(float restitutionOrthoAng);
  void setDampingOrthoAng(float dampingOrthoAng);
  void setPoweredLinMotor(boolean onOff);
  boolean getPoweredLinMotor();
  void setTargetLinMotorVelocity(float targetLinMotorVelocity);
  float getTargetLinMotorVelocity();
  void setMaxLinMotorForce(float maxLinMotorForce);
  float getMaxLinMotorForce();
  void setPoweredAngMotor(boolean onOff);
  boolean getPoweredAngMotor();
  void setTargetAngMotorVelocity(float targetAngMotorVelocity);
  float getTargetAngMotorVelocity();
  void setMaxAngMotorForce(float maxAngMotorForce);
  float getMaxAngMotorForce();
  float getLinearPos();
  float getAngularPos();
  boolean getUseFrameOffset();
  void setUseFrameOffset(boolean frameOffsetOnOff);
  void setFrames([Const, Ref] btTransform frameA, [Const, Ref] btTransform frameB);
  void setParam(long num, float value, optional long axis);
  float getParam(long num, optional long axis);
  long getFlags();
};
btSliderConstraint implements btTypedConstraint;

interface btGeneric6DofSpringConstraint {
  void btGeneric6DofSpringConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btTransform frameInA, [Const, Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameA);
  void btGeneric6DofSpringConstraint([Ref] btRigidBody rbB, [Ref] btTransform frameInB, boolean useLinearFrameReferenceFrameB);
  void enableSpring(long index, boolean onOff);
  void setStiffness(long index, float stiffness);
  void setDamping(long index, float damping);
  void setEquilibriumPoint();
  void setEquilibriumPoint(long index);
  void setEquilibriumPoint(long index, float val);
  boolean isSpringEnabled(long index);
  float getStiffness(long index);
  float getDamping(long index);
  float getEquilibriumPoint(long index);
  void setAxis([Const, Ref] btVector3 axis1, [Const, Ref] btVector3 axis2);
};
btGeneric6DofSpringConstraint implements btGeneric6DofConstraint;

interface btGearConstraint {
  void btGearConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btVector3 axisInA, [Const, Ref] btVector3 axisInB, optional float ratio);
  void setAxisA([Ref] btVector3 axisA);
  void setAxisB([Ref] btVector3 axisB);
  void setRatio(float ratio);
  [Const, Ref] btVector3 getAxisA();
  [Const, Ref] btVector3 getAxisB();
  float getRatio();
  void setParam(long num, float value, optional long axis);
  float getParam(long num, optional long axis);
};
btGearConstraint implements btTypedConstraint;

interface btFixedConstraint {
  void btFixedConstraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const,Ref] btTransform frameInA, [Const,Ref] btTransform frameInB);
};
btFixedConstraint implements btGeneric6DofSpring2Constraint;

enum RotateOrder {
  "RO_XYZ",
  "RO_XZY",
  "RO_YXZ",
  "RO_YZX",
  "RO_ZXY",
  "RO_ZYX"
};

interface btRotationalLimitMotor2 {
  void btRotationalLimitMotor2();
  attribute float m_loLimit;
  attribute float m_hiLimit;
  attribute float m_bounce;
  attribute float m_stopERP;
  attribute float m_stopCFM;
  attribute float m_motorERP;
  attribute float m_motorCFM;
  attribute boolean m_enableMotor;
  attribute float m_targetVelocity;
  attribute float m_maxMotorForce;
  attribute boolean m_servoMotor;
  attribute float m_servoTarget;
  attribute boolean m_enableSpring;
  attribute float m_springStiffness;
  attribute boolean m_springStiffnessLimited;
  attribute float m_springDamping;
  attribute boolean m_springDampingLimited;
  attribute float m_equilibriumPoint;
  attribute float m_currentLimitError;
  attribute float m_currentLimitErrorHi;
  attribute float m_currentPosition;
  attribute long m_currentLimit;
  boolean isLimited();
  void testLimitValue(float test_value);
};

interface btTranslationalLimitMotor2 {
  void btTranslationalLimitMotor2();
  [Value] attribute btVector3 m_lowerLimit;
  [Value] attribute btVector3 m_upperLimit;
  [Value] attribute btVector3 m_bounce;
  [Value] attribute btVector3 m_stopERP;
  [Value] attribute btVector3 m_stopCFM;
  [Value] attribute btVector3 m_motorERP;
  [Value] attribute btVector3 m_motorCFM;
  attribute boolean[] m_enableMotor;
  attribute boolean[] m_servoMotor;
  attribute boolean[] m_enableSpring;
  [Value] attribute btVector3 m_servoTarget;
  [Value] attribute btVector3 m_springStiffness;
  attribute boolean[] m_springStiffnessLimited;
  [Value] attribute btVector3 m_springDamping;
  attribute boolean[] m_springDampingLimited;
  [Value] attribute btVector3 m_equilibriumPoint;
  [Value] attribute btVector3 m_targetVelocity;
  [Value] attribute btVector3 m_maxMotorForce;
  [Value] attribute btVector3 m_currentLimitError;
  [Value] attribute btVector3 m_currentLimitErrorHi;
  [Value] attribute btVector3 m_currentLinearDiff;
  attribute long[] m_currentLimit;
  boolean isLimited(long limitIndex);
  void testLimitValue(long limitIndex, float test_value);
};

enum bt6DofFlags2 {
  "BT_6DOF_FLAGS_CFM_STOP2",
  "BT_6DOF_FLAGS_ERP_STOP2",
  "BT_6DOF_FLAGS_CFM_MOTO2",
  "BT_6DOF_FLAGS_ERP_MOTO2",
  "BT_6DOF_FLAGS_USE_INFINITE_ERROR"
};

interface btGeneric6DofSpring2Constraint {
  void btGeneric6DofSpring2Constraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Const, Ref] btTransform frameInA, [Const, Ref] btTransform frameInB, optional RotateOrder rotOrder);
  void btGeneric6DofSpring2Constraint([Ref] btRigidBody rbB, [Const, Ref] btTransform frameInB, optional RotateOrder rotOrder);
  void buildJacobian();
  btRotationalLimitMotor2 getRotationalLimitMotor(long index);
  btTranslationalLimitMotor2 getTranslationalLimitMotor();
  void calculateTransforms([Const, Ref] btTransform transA, [Const, Ref] btTransform transB);
  void calculateTransforms();
  [Const, Ref] btTransform getCalculatedTransformA();
  [Const, Ref] btTransform getCalculatedTransformB();
  [Ref] btTransform getFrameOffsetA();
  [Ref] btTransform getFrameOffsetB();
  [Value] btVector3 getAxis(long axis_index);
  float getAngle(long axis_index);
  float getRelativePivotPosition(long axis_index);
  void setFrames([Const, Ref] btTransform frameA, [Const, Ref] btTransform frameB);
  void setLinearLowerLimit([Const, Ref] btVector3 linearLower);
  void getLinearLowerLimit([Ref] btVector3 linearLower);
  void setLinearUpperLimit([Const, Ref] btVector3 linearUpper);
  void getLinearUpperLimit([Ref] btVector3 linearUpper);
  void setAngularLowerLimit([Const, Ref] btVector3 angularLower);
  void setAngularLowerLimitReversed([Const, Ref] btVector3 angularLower);
  void getAngularLowerLimit([Ref] btVector3 angularLower);
  void getAngularLowerLimitReversed([Ref] btVector3 angularLower);
  void setAngularUpperLimit([Const, Ref] btVector3 angularUpper);
  void setAngularUpperLimitReversed([Const, Ref] btVector3 angularUpper);
  void getAngularUpperLimit([Ref] btVector3 angularUpper);
  void getAngularUpperLimitReversed([Ref] btVector3 angularUpper);
  void setLimit(long axis, float lo, float hi);
  void setLimitReversed(long axis, float lo, float hi);
  boolean isLimited(long limitIndex);
  void setRotationOrder(RotateOrder order);
  RotateOrder getRotationOrder();
  void setAxis([Const, Ref] btVector3 axis1, [Const, Ref] btVector3 axis2);
  void setBounce(long index, float bounce);
  void enableMotor(long index, boolean onOff);
  void setServo(long index, boolean onOff);
  void setTargetVelocity(long index, float velocity);
  void setServoTarget(long index, float target);
  void setMaxMotorForce(long index, float force);
  void enableSpring(long index, boolean onOff);
  void setStiffness(long index, float stiffness);
  void setDamping(long index, float damping);
  void setEquilibriumPoint();
  void setEquilibriumPoint(long index);
  void setEquilibriumPoint(long index, float val);
  void setParam(long num, float value, optional long axis);
  float getParam(long num, optional long axis);
  float btGetMatrixElem([Const, Ref] btMatrix3x3 mat, long index);
  boolean matrixToEulerXYZ([Const, Ref] btMatrix3x3 mat, [Ref] btVector3 xyz);
  boolean matrixToEulerXZY([Const, Ref] btMatrix3x3 mat, [Ref] btVector3 xyz);
  boolean matrixToEulerYXZ([Const, Ref] btMatrix3x3 mat, [Ref] btVector3 xyz);
  boolean matrixToEulerYZX([Const, Ref] btMatrix3x3 mat, [Ref] btVector3 xyz);
  boolean matrixToEulerZXY([Const, Ref] btMatrix3x3 mat, [Ref] btVector3 xyz);
  boolean matrixToEulerZYX([Const, Ref] btMatrix3x3 mat, [Ref] btVector3 xyz);
};
btGeneric6DofSpring2Constraint implements btTypedConstraint;

interface btHinge2Constraint {
  void btHinge2Constraint([Ref] btRigidBody rbA, [Ref] btRigidBody rbB, [Ref] btVector3 anchor, [Ref] btVector3 axis1, [Ref] btVector3 axis2);
  [Const, Ref] btVector3 getAnchor();
  [Const, Ref] btVector3 getAnchor2();
  [Const, Ref] btVector3 getAxis1();
  [Const, Ref] btVector3 getAxis2();
  float getAngle1();
  float getAngle2();
  void setUpperLimit(float ang1max);
  void setLowerLimit(float ang1min);
};
btHinge2Constraint implements btGeneric6DofSpring2Constraint;

interface btConstraintSolver {};

interface btDispatcherInfo {
  attribute float m_timeStep;
  attribute long m_stepCount;
  attribute long m_dispatchFunc;
  attribute float m_timeOfImpact;
  attribute boolean m_useContinuous;
  attribute boolean m_enableSatConvex;
  attribute boolean m_enableSPU;
  attribute boolean m_useEpa;
  attribute float m_allowedCcdPenetration;
  attribute boolean m_useConvexConservativeDistanceUtil;
  attribute float m_convexConservativeDistanceThreshold;
};

interface btCollisionWorld {
  btDispatcher getDispatcher();
  void rayTest([Const, Ref] btVector3 rayFromWorld, [Const, Ref] btVector3 rayToWorld, [Ref] RayResultCallback resultCallback);
  btOverlappingPairCache getPairCache();
  [Ref] btDispatcherInfo getDispatchInfo();
  void addCollisionObject(btCollisionObject collisionObject, optional short collisionFilterGroup, optional short collisionFilterMask);
  void removeCollisionObject(btCollisionObject collisionObject);
  [Const] btBroadphaseInterface getBroadphase();
  void convexSweepTest([Const] btConvexShape castShape, [Const, Ref] btTransform from, [Const, Ref] btTransform to, [Ref] ConvexResultCallback resultCallback, float allowedCcdPenetration);
  void contactPairTest(btCollisionObject colObjA, btCollisionObject colObjB, [Ref] ContactResultCallback resultCallback);
  void contactTest(btCollisionObject colObj, [Ref] ContactResultCallback resultCallback);
  void updateSingleAabb(btCollisionObject colObj);
};

interface btContactSolverInfo {
  attribute boolean m_splitImpulse;
  attribute long m_splitImpulsePenetrationThreshold;
  attribute long m_numIterations;
};

interface btDynamicsWorld {
  void addAction(btActionInterface action);
  void removeAction(btActionInterface action);
  [Ref] btContactSolverInfo getSolverInfo();
};
btDynamicsWorld implements btCollisionWorld;

interface btDiscreteDynamicsWorld {
  void btDiscreteDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);

  void setGravity([Ref] btVector3 gravity);
  [Value] btVector3 getGravity();

  void addRigidBody(btRigidBody body);
  void addRigidBody(btRigidBody body, short group, short mask);
  void removeRigidBody(btRigidBody body);

  void addConstraint(btTypedConstraint constraint, optional boolean disableCollisionsBetweenLinkedBodies);
  void removeConstraint(btTypedConstraint constraint);

  long stepSimulation(float timeStep, optional long maxSubSteps, optional float fixedTimeStep);

  // Contact callback support
  // void setContactAddedCallback(long funcpointer);
  // void setContactProcessedCallback(long funcpointer);
  // void setContactDestroyedCallback(long funcpointer);
};
btDiscreteDynamicsWorld implements btDynamicsWorld;

[Prefix="btRaycastVehicle::", NoDelete]
interface btVehicleTuning {
  void btVehicleTuning();
  attribute float m_suspensionStiffness;
  attribute float m_suspensionCompression;
  attribute float m_suspensionDamping;
  attribute float m_maxSuspensionTravelCm;
  attribute float m_frictionSlip;
  attribute float m_maxSuspensionForce;
};

[Prefix="btDefaultVehicleRaycaster::"]
interface btVehicleRaycasterResult {
    [Value] attribute btVector3 m_hitPointInWorld;
    [Value] attribute btVector3 m_hitNormalInWorld;
    attribute float m_distFraction;
};

interface btVehicleRaycaster {
    void castRay ([Const, Ref] btVector3 from, [Const, Ref] btVector3 to, [Ref] btVehicleRaycasterResult result);
};

interface btDefaultVehicleRaycaster {
  void btDefaultVehicleRaycaster(btDynamicsWorld world);
};
btDefaultVehicleRaycaster implements btVehicleRaycaster;

[Prefix="btWheelInfo::"]
interface RaycastInfo {
  [Value] attribute btVector3 m_contactNormalWS;
  [Value] attribute btVector3 m_contactPointWS;
  attribute float m_suspensionLength;
  [Value] attribute btVector3 m_hardPointWS;
  [Value] attribute btVector3 m_wheelDirectionWS;
  [Value] attribute btVector3 m_wheelAxleWS;
  attribute boolean m_isInContact;
  attribute any m_groundObject;
};

interface btWheelInfoConstructionInfo {
    [Value] attribute btVector3 m_chassisConnectionCS;
    [Value] attribute btVector3 m_wheelDirectionCS;
    [Value] attribute btVector3 m_wheelAxleCS;
    attribute float m_suspensionRestLength;
    attribute float m_maxSuspensionTravelCm;
    attribute float m_wheelRadius;
    attribute float m_suspensionStiffness;
    attribute float m_wheelsDampingCompression;
    attribute float m_wheelsDampingRelaxation;
    attribute float m_frictionSlip;
    attribute float m_maxSuspensionForce;
    attribute boolean m_bIsFrontWheel;
};

interface btWheelInfo {
  attribute float m_suspensionStiffness;
  attribute float m_frictionSlip;
  attribute float m_engineForce;
  attribute float m_rollInfluence;
  attribute float m_suspensionRestLength1;
  attribute float m_wheelsRadius;
  attribute float m_wheelsDampingCompression;
  attribute float m_wheelsDampingRelaxation;
  attribute float m_steering;
  attribute float m_maxSuspensionForce;
  attribute float m_maxSuspensionTravelCm;
  attribute float m_wheelsSuspensionForce;
  attribute boolean m_bIsFrontWheel;
  [Value] attribute RaycastInfo m_raycastInfo;
  [Value] attribute btVector3 m_chassisConnectionPointCS;
  void btWheelInfo([Ref] btWheelInfoConstructionInfo ci);
  float getSuspensionRestLength ();
  void  updateWheel ([Const, Ref] btRigidBody chassis, [Ref] RaycastInfo raycastInfo);
  [Value] attribute btTransform m_worldTransform;
  [Value] attribute btVector3 m_wheelDirectionCS;
  [Value] attribute btVector3 m_wheelAxleCS;
  attribute float m_rotation;
  attribute float m_deltaRotation;
  attribute float m_brake;
  attribute float  m_clippedInvContactDotSuspension;
  attribute float  m_suspensionRelativeVelocity;
  attribute float  m_skidInfo;
};

interface btActionInterface {
    void updateAction (btCollisionWorld collisionWorld, float deltaTimeStep);
};

interface btRaycastVehicle {
  void btRaycastVehicle([Const, Ref] btVehicleTuning tuning, btRigidBody chassis, btVehicleRaycaster raycaster);
  void applyEngineForce(float force, long wheel);
  void setSteeringValue(float steering, long wheel);
  [Const, Ref] btTransform getWheelTransformWS(long wheelIndex);
  void updateWheelTransform(long wheelIndex, boolean interpolatedTransform);
  [Ref] btWheelInfo addWheel([Const, Ref] btVector3 connectionPointCS0, [Const, Ref] btVector3 wheelDirectionCS0, [Const, Ref] btVector3 wheelAxleCS, float suspensionRestLength, float wheelRadius, [Const, Ref] btVehicleTuning tuning, boolean isFrontWheel);
  long getNumWheels();
  btRigidBody getRigidBody();
  [Ref] btWheelInfo getWheelInfo(long index);
  void setBrake(float brake, long wheelIndex);
  void setCoordinateSystem(long rightIndex, long upIndex, long forwardIndex);
  float getCurrentSpeedKmHour();
  [Const, Ref] btTransform getChassisWorldTransform();
  float rayCast([Ref] btWheelInfo wheel);
  void updateVehicle(float step);
  void resetSuspension();
  float getSteeringValue(long wheel);
  void updateWheelTransformsWS([Ref] btWheelInfo wheel, optional boolean interpolatedTransform);
  void setPitchControl(float pitch);
  void updateSuspension(float deltaTime);
  void updateFriction(float timeStep);
  long getRightAxis();
  long getUpAxis();
  long getForwardAxis();
  [Value] btVector3 getForwardVector();
  long getUserConstraintType();
  void setUserConstraintType(long userConstraintType);
  void setUserConstraintId(long uid);
  long getUserConstraintId();
};
btRaycastVehicle implements btActionInterface;

interface btGhostObject {
  void btGhostObject();
  long getNumOverlappingObjects();
  btCollisionObject getOverlappingObject(long index);
};
btGhostObject implements btCollisionObject;

interface btPairCachingGhostObject {
  void btPairCachingGhostObject();
};
btPairCachingGhostObject implements btGhostObject;

// Soft bodies

interface btSoftBodyWorldInfo {
  void btSoftBodyWorldInfo();
  attribute float air_density;
  attribute float water_density;
  attribute float water_offset;
  attribute float m_maxDisplacement;
  [Value] attribute btVector3 water_normal;
  attribute btBroadphaseInterface m_broadphase;
  attribute btDispatcher m_dispatcher;
  [Value] attribute btVector3 m_gravity;
};

[Prefix="btSoftBody::"]
interface Face {
  attribute Node[] m_n;
  [Value] attribute btVector3 m_normal;
  attribute float m_ra;
};

[Prefix="btSoftBody::"]
interface tFaceArray {
  [Const] long size();
  [Const, Ref] Face at(long n);
};

[Prefix="btSoftBody::"]
interface Node {
  [Value] attribute btVector3 m_x;
  [Value] attribute btVector3 m_q;
  [Value] attribute btVector3 m_v;
  [Value] attribute btVector3 m_f;
  [Value] attribute btVector3 m_n;
  attribute float m_im;
  attribute float m_area;
};

[Prefix="btSoftBody::"]
interface tNodeArray {
  [Const] long size();
  [Const, Ref] Node at(long n);
};

[Prefix="btSoftBody::"]
interface Material {
  attribute float m_kLST;
  attribute float m_kAST;
  attribute float m_kVST;
  attribute long m_flags;
};

[Prefix="btSoftBody::"]
interface tMaterialArray {
  [Const] long size();
  Material at(long n);
};

[Prefix="btSoftBody::"]
interface Anchor {
  attribute Node m_node;
  [Value] attribute btVector3 m_local;
  attribute btRigidBody m_body;
  attribute float m_influence;
  [Value] attribute btMatrix3x3 m_c0;
  [Value] attribute btVector3 m_c1;
  attribute float m_c2;
};

[Prefix="btSoftBody::"]
interface tAnchorArray {
  [Const] long size();
  [Value] Anchor at(long n);
  void clear();
  void push_back([Ref] Anchor val);
  void pop_back();
};

[Prefix="btSoftBody::"]
interface Config {
  attribute float kVCF;
  attribute float kDP;
  attribute float kDG;
  attribute float kLF;
  attribute float kPR;
  attribute float kVC;
  attribute float kDF;
  attribute float kMT;
  attribute float kCHR;
  attribute float kKHR;
  attribute float kSHR;
  attribute float kAHR;
  attribute float kSRHR_CL;
  attribute float kSKHR_CL;
  attribute float kSSHR_CL;
  attribute float kSR_SPLT_CL;
  attribute float kSK_SPLT_CL;
  attribute float kSS_SPLT_CL;
  attribute float maxvolume;
  attribute float timescale;
  attribute long viterations;
  attribute long piterations;
  attribute long diterations;
  attribute long citerations;
  attribute long collisions;
};

interface btSoftBody {
  void btSoftBody(btSoftBodyWorldInfo worldInfo, long node_count, btVector3 x, float[] m);

  [Value] attribute Config m_cfg;
  [Value] attribute tNodeArray m_nodes;
  [Value] attribute tFaceArray m_faces;
  [Value] attribute tMaterialArray m_materials;
  [Value] attribute tAnchorArray m_anchors;

  [Const] boolean checkLink( long node0, long node1);
  [Const] boolean checkFace( long node0, long node1, long node2);
  Material appendMaterial();
  void appendNode( [Const, Ref] btVector3 x, float m);
  void appendLink( long node0, long node1, Material mat, boolean bcheckexist);
  void appendFace( long node0, long node1, long node2, Material mat);
  void appendTetra( long node0, long node1, long node2, long node3, Material mat);
  void appendAnchor( long node, btRigidBody body, boolean disableCollisionBetweenLinkedBodies, float influence);
  void addForce([Const, Ref] btVector3 force);
  void addForce([Const, Ref] btVector3 force, long node);
  void addAeroForceToNode([Const, Ref] btVector3 windVelocity, long nodeIndex);
  [Const] float getTotalMass();
  void setTotalMass( float mass, boolean fromfaces);
  void setMass(long node, float mass);
  void transform( [Const, Ref] btTransform trs);
  void translate( [Const, Ref] btVector3 trs);
  void rotate( [Const, Ref] btQuaternion rot);
  void scale(  [Const, Ref] btVector3 scl);
  long generateClusters(long k, optional long maxiterations);
  long generateBendingConstraints(long distance, Material mat);
  btSoftBody upcast(btCollisionObject colObj);
  float getRestLengthScale();
  void setRestLengthScale(float restLength);
};
btSoftBody implements btCollisionObject;

interface btSoftBodyRigidBodyCollisionConfiguration {
  void btSoftBodyRigidBodyCollisionConfiguration([Ref] optional btDefaultCollisionConstructionInfo info);
};
btSoftBodyRigidBodyCollisionConfiguration implements btDefaultCollisionConfiguration;

interface btSoftBodySolver {
};

interface btDefaultSoftBodySolver {
  void btDefaultSoftBodySolver ();
};
btDefaultSoftBodySolver implements btSoftBodySolver;

interface btSoftBodyArray {
  [Const] long size();
  [Const] btSoftBody at(long n);
};

interface btSoftRigidDynamicsWorld {
  void btSoftRigidDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration, btSoftBodySolver softBodySolver);

  void addSoftBody(btSoftBody body, short collisionFilterGroup, short collisionFilterMask);
  void removeSoftBody(btSoftBody body);
  void removeCollisionObject(btCollisionObject collisionObject);

  [Ref] btSoftBodyWorldInfo getWorldInfo();
  [Ref] btSoftBodyArray getSoftBodyArray();
};
btSoftRigidDynamicsWorld implements btDiscreteDynamicsWorld;

interface btSoftBodyHelpers {
  void btSoftBodyHelpers();

  btSoftBody CreateRope([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 from, [Const, Ref] btVector3 to, long res, long fixeds);
  btSoftBody CreatePatch([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 corner00, [Const, Ref] btVector3 corner10, [Const, Ref] btVector3 corner01, [Const, Ref] btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags, optional float perturbation);
  btSoftBody CreatePatchUV([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 corner00, [Const, Ref] btVector3 corner10, [Const, Ref] btVector3 corner01, [Const, Ref] btVector3 corner11, long resx, long resy, long fixeds, boolean gendiags, optional float[] tex_coords);
  float CalculateUV(long resx, long resy, long ix, long iy, long id);
  btSoftBody CreateEllipsoid([Ref] btSoftBodyWorldInfo worldInfo, [Const, Ref] btVector3 center, [Const, Ref] btVector3 radius, long res);
  btSoftBody CreateFromTriMesh([Ref] btSoftBodyWorldInfo worldInfo, [Const] float[] vertices, [Const] long[] triangles, long ntriangles, optional boolean randomizeConstraints);
  btSoftBody CreateFromConvexHull([Ref] btSoftBodyWorldInfo worldInfo, [Const] btVector3 vertices, long nvertices, optional boolean randomizeConstraints);
};